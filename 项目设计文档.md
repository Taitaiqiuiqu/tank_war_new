# 坦克大战 P2P 局域网联机项目架构设计
## 一、整体架构
采用**无中心 P2P 对等架构**，局域网内的设备无主从严格区分（仅存在「主机/客户端」的连接发起差异），每台设备同时承担「数据发送端」和「数据接收端」角色，核心分为四层架构，层间解耦且单向依赖（上层调用下层，下层不感知上层）：
```
┌─────────────────┐
│ UI 展示层       │ —— 联机交互、状态展示
├─────────────────┤
│ 游戏逻辑层      │ —— 核心玩法、状态管理
├─────────────────┤
│ 状态同步层      │ —— 数据标准化、同步策略
├─────────────────┤
│ 网络通信层      │ —— 局域网连接、数据收发
└─────────────────┘
```

### 1.1 架构核心原则
- 对等性：所有联机设备逻辑对等，无中心服务器，仅通过局域网直连通信；
- 低延迟优先：优先采用 UDP 协议传输实时数据，TCP 仅兜底关键指令；
- 状态一致性：通过增量同步+全量校准，保证多端游戏状态无明显偏差；
- 解耦性：各层独立封装，网络层不耦合游戏逻辑，同步层不感知 UI 展示。

## 二、网络通信层设计
### 2.1 协议选型与分工
| 通信协议 | 核心用途                | 设计考量                                                                 |
|----------|-------------------------|--------------------------------------------------------------------------|
| UDP      | 实时状态同步（高频）| 无连接、低延迟，适配坦克位置、子弹轨迹、方向等 16ms/帧级别的实时数据传输； |
| TCP      | 连接管理（低频）| 可靠传输，用于局域网发现确认、连接建立/断开、断线重连、关键指令（如死亡/计分）兜底； |

### 2.2 局域网发现机制
- 主机侧：启动后绑定固定 UDP 广播端口（如 8888），每秒向局域网广播地址（255.255.255.255）发送包含「主机 IP、房间名称、当前联机人数」的广播包；同时启动 TCP 监听（如 8889 端口），等待客户端连接确认。
- 客户端侧：启动后监听 UDP 广播端口，扫描周期为 2 秒/次，接收主机广播包后解析可用联机列表；选择目标主机后，通过 TCP 连接主机监听端口，完成连接确认。

### 2.3 连接管理逻辑
1. 建立阶段：客户端 TCP 连接主机 → 双方交换「通信端口、玩家标识」→ 确认 UDP 直连地址 → 关闭 TCP 临时连接，转为 UDP 持续通信；
2. 维持阶段：每 3 秒发送 UDP 心跳包，检测对端在线状态；
3. 断开阶段：连续 5 次心跳无响应则判定断线，触发 UI 断线提示，保留 10 秒重连窗口；
4. 重连阶段：断线后客户端自动重试扫描原主机，重连成功后通过全量同步恢复游戏状态。

### 2.4 数据收发设计
- 端口规划：UDP 固定业务端口（8888），TCP 固定连接端口（8889），避免端口冲突；
- 数据缓冲区：设置 1024 字节缓冲区，适配轻量化游戏数据；
- 线程模型：采用「主线程+守护线程」模式，主线程处理游戏逻辑，独立守护线程负责 UDP/TCP 数据收发，避免通信阻塞游戏帧更新；
- 异常处理：封装网络异常（断网、端口占用、超时），统一转为「连接状态码」向上层反馈，避免程序崩溃。

## 三、状态同步层设计
### 3.1 数据标准化
#### 3.1.1 核心同步数据结构
定义统一的 JSON 格式数据包，所有同步数据需遵循该规范，保证多端解析一致性：
| 数据包类型       | 核心字段                                                                 | 传输频率       |
|------------------|--------------------------------------------------------------------------|----------------|
| 扫描响应包       | type:scan_response、room_name、ip、timestamp                             | 1 次/秒（主机） |
| 连接确认包       | type:connect_ack、player_id、peer_ip、timestamp                          | 1 次/连接      |
| 状态同步包       | type:state_sync、player_id、timestamp、tank（位置/方向/血量）、bullets（子弹列表）、score | 1 次/帧（16ms） |
| 全量校准包       | type:full_sync、timestamp、all_tanks、all_bullets、map_state、score       | 1 次/5 秒      |
| 心跳包           | type:heartbeat、player_id、online_status                                 | 1 次/3 秒      |

#### 3.1.2 数据校验
- 时间戳：所有数据包携带毫秒级时间戳，用于多端状态时间对齐，避免帧序错乱；
- 简单校验：对核心字段（如血量、分数）计算 CRC32 校验值，丢弃校验失败的异常数据包，防止数据篡改或传输错误。

### 3.2 同步策略
#### 3.2.1 增量同步（核心）
- 触发条件：仅当坦克位置变化≥1 像素、方向改变、子弹生成/消失、血量变化时，发送增量数据；
- 数据粒度：仅传输变化字段（如仅传 x/y 坐标，不传无变化的方向字段），减少数据包体积；
- 传输频率：与游戏帧率同步（60 帧/秒），每帧仅发送本端玩家的状态增量。

#### 3.2.2 全量校准（兜底）
- 触发条件：每 5 秒主动发送 1 次；或检测到多端状态偏差≥5 像素（如对端坦克位置与本地预测偏差过大）时，触发即时校准；
- 数据范围：包含所有玩家坦克状态、子弹列表、地形交互状态（如砖墙破损）、计分数据，用于校正增量同步的累积偏差。

#### 3.2.3 延迟补偿
- 客户端预测：本地玩家操作（如移动、射击）先在本地执行，再同步给对端，减少操作到反馈的延迟感；
- 插值平滑：接收对端坦克状态后，采用线性插值（16ms 内平滑过渡）更新位置，避免画面抖动；
- 时间戳对齐：基于数据包时间戳，将对端状态映射到本地游戏帧，减少帧不同步导致的「瞬移」问题。

## 四、游戏逻辑层设计
### 4.1 核心逻辑封装
- 状态管理：封装「全局游戏状态对象」，包含所有玩家坦克、子弹、地形、计分等核心数据，作为同步层的唯一数据来源；
- 逻辑隔离：本地玩家逻辑与对端玩家逻辑隔离，本地操作直接修改状态，对端状态仅通过同步层更新；
- 碰撞检测：多端独立执行碰撞检测（坦克-地形、坦克-子弹、子弹-地形），仅同步碰撞结果（如血量变化），减少同步数据量。

### 4.2 联机模式适配
- 双人对抗模式：多端共享「敌方坦克标识」，各自渲染对方坦克，碰撞判定独立执行，计分同步到对端；
- 合作打 AI 模式：主机生成 AI 坦克并同步 AI 状态，客户端仅渲染和交互 AI，AI 逻辑统一由主机驱动，保证多端 AI 行为一致。

## 五、UI 展示层设计
### 5.1 核心 UI 模块
- 联机菜单：包含「创建房间（主机）」「加入房间（客户端）」「刷新局域网列表」等功能，基于 Pygame_gui 封装；
- 状态面板：实时展示「联机状态（连接中/已连接/断线）、对端延迟、自身/对端血量、计分」；
- 提示组件：断线重连提示、连接失败提示、同步异常提示，适配复古像素风格；

### 5.2 状态联动逻辑
- UI 仅订阅「网络层连接状态码」「同步层状态数据」，不直接操作网络/同步逻辑；
- 联机状态变化（如断线）触发 UI 提示的同时，暂停游戏逻辑，等待重连或退出；
- 延迟展示：基于 UDP 数据包往返时间（RTT）计算延迟，实时更新到 UI 面板（单位：ms）。

## 六、关键异常处理架构
### 6.1 网络异常
- 断网：检测到心跳超时后，暂停游戏画面，弹出重连窗口，保留当前游戏状态 10 秒；
- 丢包：UDP 增量包丢包时，依赖下帧增量包补充；关键包（如血量变化）丢包时，触发 TCP 重传；
- 端口占用：启动时检测端口是否被占用，自动切换备用端口（如 8888→8890），并在 UI 提示端口变更；

### 6.2 状态异常
- 同步偏差：当对端坦克位置与本地预测偏差≥10 像素时，触发即时全量校准，平滑修正位置；
- 数据冲突：多端同时操作同一地形（如同时射击同一砖墙），以「时间戳更早」的操作结果为准，同步给对端。
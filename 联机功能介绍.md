# 联机功能介绍 (Multiplayer Feature Introduction)

## 1. 架构概述 (Architecture Overview)

本项目采用 **C/S (Client-Server) 架构**，其中主机 (Host) 充当权威服务器 (Authoritative Server)，同时也是一个玩家客户端。

*   **Host (主机)**: 负责游戏核心逻辑运算、物理模拟、伤害判定、AI控制，并维护权威的游戏世界状态。
*   **Client (客户端)**: 负责采集本地玩家输入、发送给主机、接收主机下发的世界状态并进行渲染。为了提升体验，客户端采用了**客户端预测 (Client-Side Prediction)** 技术。

## 2. 通讯协议 (Communication Protocol)

网络层 (`NetworkManager`) 使用 Python 的 `socket` 模块实现，包含两种通讯方式:

*   **UDP 广播**: 用于局域网内的房间发现 (Discovery)。
    *   Client 发送 `scan` 广播。
    *   Host 收到后回复 `scan_response`，包含房间名和 IP。
*   **TCP 长连接**: 用于游戏控制信令及状态同步。
    *   保证数据传输的可靠性和顺序。
    *   采用 JSON 格式传输数据，以换行符 `\n` 分隔消息。

## 3. 数据流向 (Data Flow)

### 3.1 客户端 -> 主机 (Input)
客户端不直接修改游戏状态（除了本地预测），而是将玩家的操作指令发送给主机。
*   **消息类型**: `input`
*   **内容**: 移动方向 (`move`)、射击指令 (`shoot`)。
*   **频率**: 每帧发送（或状态改变时发送）。

### 3.2 主机 -> 客户端 (State Sync)
主机每帧执行游戏逻辑后，将整个游戏世界的快照 (Snapshot) 发送给客户端。
*   **消息类型**: `state`
*   **内容**:
    *   **Tanks**: 所有存活坦克的 ID、位置、方向、速度、血量、护盾状态。
    *   **Bullets**: 所有子弹的位置、方向、归属。
    *   **Events**: 爆炸特效、销毁的墙体等一次性事件。
    *   **Meta**: 游戏结束状态、获胜者。

## 4. 同步机制 (Synchronization Mechanisms)

### 4.1 权威状态 (Authoritative State)
主机拥有最终解释权。如果客户端的状态与主机不一致,客户端必须修正。

### 4.2 客户端预测 (Client-Side Prediction)
为了消除网络延迟带来的操作滞后感,客户端在按下按键时会立即移动本地坦克,而不是等待服务器确认。

**实现细节**:
*   **预测**: 客户端在 `game.py` 的 `update()` 中本地更新 `player_tank` 的位置 (line 367-368)。
*   **部分同步**: 在 `state_manager.py` 的 `decode_state()` 中,对于本地玩家坦克:
    *   **不同步**: 位置 (x, y)、方向 (direction) - 由客户端预测控制
    *   **同步**: 血量 (health)、护盾状态 (shield_active)、存活状态 (active) - 由服务器权威控制
*   **和解 (Reconciliation)**: 在 `game.py` 中通过 `my_tank` 字段进行位置误差修正 (line 382-397)。如果误差超过阈值(5像素),则平滑插值修正。

### 4.3 死亡同步 (Death Synchronization)
**问题**: 早期版本中,客户端完全跳过本地玩家的状态同步 (`if local_player_id and tid == local_player_id: continue`),导致客户端永远不会收到自己坦克的死亡通知。

**解决方案** (已修复):
1.  **主机**: 判定坦克死亡后,调用 `tank.destroy()` 设置 `active=False`。下一帧的状态快照中将不再包含该坦克的 ID。
2.  **传输**: 主机发送的 `tanks` 列表中不包含已死亡的坦克。
3.  **客户端**: `StateManager.decode_state()` 执行两个关键步骤:
    *   **步骤1**: 遍历服务器发来的坦克列表,对于本地玩家坦克,**仅同步血量和护盾状态**,不覆盖位置(保持客户端预测)。
    *   **步骤2**: 遍历本地所有坦克,如果某个坦克的 ID **不在**服务器发来的列表中(包括本地玩家!),则标记为 `active=False` 和 `visible=False`。

**关键代码逻辑**:
```python
# 步骤1: 同步存活坦克的状态
for t_data in remote_tanks.values():
    if local_player_id and tid == local_player_id:
        # 本地玩家:仅同步血量等关键状态
        tank.health = t_data.get("hp", 100)
    else:
        # 远程玩家:全量同步
        tank.x = t_data["x"]
        ...
    tank.active = True  # 在服务器列表中的坦克都是存活的

# 步骤2: 禁用不在服务器列表中的坦克(死亡的坦克)
for tank in self.world.tanks:
    if tank.tank_id not in remote_tanks:
        tank.active = False   # 包括本地玩家!
        tank.visible = False
```

## 5. 代码模块 (Code Modules)

*   `src/network/network_manager.py`: 处理 Socket 连接、发送和接收消息队列。
*   `src/state_sync/state_manager.py`: 负责状态的序列化 (Encode) 和反序列化 (Decode)，以及快照的应用。
*   `src/game_engine/game.py`: 游戏主循环，协调网络层和游戏世界的更新。

## 6. 常见问题 (Common Issues)

### 6.1 客户端坦克死亡后不消失
**症状**: 服务端显示客户端坦克正常消失，但客户端仍可看到并控制自己的坦克。

**原因**: 客户端预测逻辑跳过了本地玩家的所有状态同步，包括 `active` 状态。

**解决**: 修改 `decode_state()` 使其对本地玩家仅跳过位置同步，但仍同步健康和存活状态。

### 6.2 重新游戏时坦克移动异常
**症状**: 游戏重启后，坦克自动朝之前的方向移动。

**原因**: `_movement_stack` 未在游戏重置时清空。

**解决**: 在 `setup_multiplayer_world()` 和 `_setup_single_player_world()` 中添加 `self._movement_stack.clear()`。
